Синхронизация(Lock)
----------------------------------
Для каких задач нужна асинхронность?
- освобождения UI
- возможность выполнения других задач пока выполняется задача
- нечувствительность алгоритма к порядку выполнения действий

Например, нужно посчитать годовую инфляцию, тогда как известны показатели за каждый месяц.
НБУ публикует открытые данные (месячная инфляция), запрос данных за отдельный месяц - обращения
к сети, что есть долгим процесом.
Если порядок вычисления месяцев не имеет значения, то эти процессы можно выполнять асинхронно.

Обоснование: (100 + 10%) + 20% =?= (100 + 20%) + 10%
10% -- x1.1, +20% -- x1.2
100 x 1.1 x 1.2 == 100 x 1.2 x 1.1 - зависимости от порядка нет
=> можно решать асинхронно

s = sum - sleep - sum *= 1.1            |  Любая из этих схем нормально работает в синхронном режиме
(s = 100)								|  ------------
-s=100--------------------sum=110-		|              ------------
-s=100--------------------sum=110-		|                          ------------
-s=100--------------------sum=110-		|
										|  Проблема в синхронности - в возможности одновременных действий
sleep - s = sum *= 1.1					|  и порядок этих действий непредсказуемый
(s = 100)								|
----- s=100 sum=110						|
 ----- s=110 sum=121					|
 ----- s=110 sum=121					|

Решение - синхронизация

----------------------------------

Синхронизация - заходи с созданием "транзакций", набором операций которые не могут выполняться одновременно
с другими транзакциями.

Создание синхронизации:
  - создаём поле с типом object:  object myLocker = new();
  - создаём в методе который запущен в другом потоке блок синхронизации:  lock (myLocker) { }
      блок синхронизации (lock), переводит myLocker в "закрытое" состояние, а завершение блока "открывает" myLocker.
      Пока myLocker "закрытый", другие инструкции(в др. потоках) с блоком lock не начинают работу, ожидая на "открытия" объекта синхронизации
  - в это блоке желательно указываются инструкции, которые работают с общим ресурсом(полем)

// без синхронизации                  // с синхронизацией (порядок не важен)
----- s=100 sum=110	----------		 | ----- s=100 sum=110	----------
 ----- s=110 sum=121 ----------		 |   -----                        s=121 sum=132 ----------
 ----- s=110 sum=121 ----------	     |   -----            s=110 sum=121 ----------

Попытка создания транзакции на все тело метода по факту "снимает" асинхронность и все методы
ждут своей очереди и срабатывают по одному.
Если код не позволяет выделить транзакцию меньше, чем все тело, то такой код следует переписать,
перемещая работу с ОБЩИМ РЕСУРСОМ в насколько можно меньшие блоки.

-------------------------------------------
calc(-) - $str(--- -----) - invoke(--- -----[разная работоспособность в зависимотси от данных])

// каждый поток выполняется то быстрее всех, то медленее
--- calc-----@str-----invoke   ->  third/fourth(в зависимости от постановки в Dispatcher)
---  calc---@str----invoke     ->  first(вывод первым)
---   calc-----@str----invoke  ->  last(вывод последним)
---    calc---@str---invoke    ->  second(вывод вторым)
---     calc---@str---invoke   ->  third/fourth(в зависимости от постановки в Dispatcher)

Примитивы синхронизации
Есть у системы "сигнальные" объекты - которые сигнализируют сиситеме про изменения своего состояния.
Отдельные из них используются для задач синхронизации.
X - ожидание, 0 - работа
--------X     0----X----
--------X     |    0----
--------0-----X---
Критическая секция (памяти) - один из простейших объектов синхронизации и такая секция есть у каждого
ref-type объекта .NET
lock переводит критичную секцию объекта к закрытому состоянию.
Это не даёт другим потокам войти в блок lock (с тем же объектом синхронизации).
  sumLocker 0000000XXXXXXX0XXXXXX00000
---lock(sumLocker) {------}------
 ---lock(sumLocker) |      {-----}

Почему стоит использовать отдельный объект для синхронизации?
string str = "Hello";
lock(str) {
    str += " ";  // строки - не меняются, str += ' ' --> str = new String(str + ' ')
}
В этом случае str никогда не разблокируется.
Поэтому рекомендуется к lock(X) ставить const объекты.
