Параллельное (асинхронное) программирование
Часть 1. Многопоточность

Введение.
В зависимости от последовательности выполнения инструкций в коде программирование
разделяют на синхронное и асинхронное.

- В синхронном режиме, код выполняется последовательно, инструкция к инструкции.
  ---------     -------     -----------------------     ----

- Асинхронный режим предполагает непоследовательное выполнение, когда за определенный
промежуток времени выполняется несколько инструкций.
  -----------                   |    --  ---  ----
      ----  ---------------     |      --   --    --   ----------------
            ---                 |                   ---
                                |

Асинхронность реализуется через:
  - многозадачность: уровень языка(платформы) с объектами Task (Promise, Future, Coroutine)
  - многопоточность: уровень ОС, предоставление ресурсов типу Thread (поток)
  - многопроцессорность: уровень ОС, процес "выше" потока - отдельные запуски программ
  - сетевые технологии (grid-, network technologies)



Многопоточность.
Поток - "последовательность кода", очередь, конвейер, которая способна паралельно с другими потоками.
Поток создаётся на ф-ции/методе, который ничего не возвращает и принимает один или ни одного аргумента:
    private void IncrementProgress() {}

Создание и вызов потока:  new Thread(IncrementProgress3).Start();

// ОШИБКА: с одного потока нельзя изменять элементы, которые принадлежат другому потоку.
(Проблема только для визуальных компонентов, для обычных полей нет)
UI ------PB-------- Start() ---PB-----------   PB - ProgressBar
                               |
new Thread              -------PB.Val=10 -> Exception


// КАК ДОЛЖНО БЫТЬ
UI ------PB-------- Start() ---PB--{PB.Val=10}--------{PB.Val=20}
                                    |                      |
new Thread              -------Invoke(PB.Val=10)-------Invoke(PB.Val=20) -> good

Конкуренция потоков: обращение к одному адресу в памяти одновременно.
Возникает когда используется обычные переменные (поля класса)
Частично решается созданием аксессоров (гет, сет) - свойства.
(частично - для одной операции: x = 10 -- OK, x += 10 -- NO [get + 10 - set])

Токены отмены:
           Основной поток
            CTS - источник - может управлять несколькими потоками (группой)
            CTS.Token;       CTS.Token
            /                    \
           /       CTS.Cancel     \    отмена будет распространена на все токены с данного источника
          /         /     \        \
       поток 1     /       \     поток 2
       if (token...)          if (token...)
