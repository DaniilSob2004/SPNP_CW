Параллельное (асинхронное) программирование
Часть 1. Многопоточность

Введение.
В зависимости от последовательности выполнения инструкций в коде программирование
разделяют на синхронное и асинхронное.

- В синхронном режиме, код выполняется последовательно, инструкция к инструкции.
  ---------     -------     -----------------------     ----

- Асинхронный режим предполагает непоследовательное выполнение, когда за определенный
промежуток времени выполняется несколько инструкций.
  -----------                   |    --  ---  ----
      ----  ---------------     |      --   --    --   ----------------
            ---                 |                   ---
                                |

Асинхронность реализуется через:
  - многозадачность: уровень языка(платформы) с объектами Task (Promise, Future, Coroutine)
  - многопоточность: уровень ОС, предоставление ресурсов типу Thread (поток)
  - многопроцессорность: уровень ОС, процес "выше" потока - отдельные запуски программ
  - сетевые технологии (grid-, network technologies)



Многопоточность.
Поток - "последовательность кода", очередь, конвейер, которая способна паралельно с другими потоками.
Поток создаётся на ф-ции/методе, который ничего не возвращает и принимает один или ни одного аргумента:
    private void Method() {}

Создание и вызов потока:  new Thread(Method).Start();

// ОШИБКА: с одного потока нельзя изменять элементы, которые принадлежат другому потоку.
(Проблема только для визуальных компонентов, для обычных полей нет)
UI ------PB-------- Start() ---PB-----------   (PB - ProgressBar)
                               |
new Thread              -------PB.Val=10 -> Exception


// КАК ДОЛЖНО БЫТЬ
Необходимо делегировать выполнения действия(лямбды) к оконному(UI) потоку:  this.Dispatcher.Invoke(() => обращение к UI-элементу);
UI ------PB-------- Start() ---PB--{PB.Val=10}--------{PB.Val=20}
                                    |                      |
new Thread              -------Invoke(PB.Val=10)-------Invoke(PB.Val=20) -> good

Передача данных в другой поток:
  - Создаём свой класс, в котором будут свойства, которые необходимо передать потоку
  - В методе который вызывается в другом потоке, необходимо добавить один параметр типа object?
  - При вызове потока, в метод Start() передаём экземпляр объекта нашего класса, с уже установленными значениями (Start(new MyClass {}))

Почему лучше использовать свойства?
    Конкуренция потоков: обращение к одному адресу в памяти одновременно.
    Возникает когда используется обычные переменные (поля класса)
    Частично решается созданием аксессоров (гет, сет) - свойства.
    (частично - для одной операции: x = 10 -- OK, x += 10 -- NO [get + 10 - set])

Как правильно делать остановку потоков:
  - объявляем источник токенов отмены:  CancellationTokenSource cts;
  - в свойствах нашего класса(который передаём в поток) создаём поле токена:  CancellationToken CancellToken { get; set; }
  - при запуске потока в метод Start() передаём наш экземпляр класса, в котором присваиваем полю значение токена:  CancellToken = cts.Token
  - отмена потоков выполняется через источник токенов в любой части кода:  cts?.Cancel();
  - в самом методе который запущен в другом потоке, нужно проверить, остановлен ли поток, есть 2 способа, с помощью:
    1. свойства, который возвращает true, если поток остановлен -> myClass.CancellToken.IsCancellationRequested
    2. исключения -> myClass.CancellToken.ThrowIfCancellationRequested();

Токены отмены:
           Основной поток
            CTS - источник - может управлять несколькими потоками (группой)
            CTS.Token;       CTS.Token
            /                    \
           /       CTS.Cancel     \    отмена будет распространена на все токены с данного источника
          /         /     \        \
       поток 1     /       \     поток 2
       if (token...)          if (token...)



